//@version=6
//@author=dirtpupfc
//@description=Bitcoin Cycles Validation Strategy - Tests indicator outputs and logic
// This strategy validates the Bitcoin Cycles Indicator by using its outputs

strategy("Bitcoin Cycles Validation Strategy", overlay=true,
         default_qty_type=strategy.percent_of_equity, default_qty_value=100)

// VALIDATION STRATEGY USAGE:
// 1. Load the main "Bitcoin Cycles Indicator" first
// 2. Load this validation strategy on the SAME chart
// 3. Set to "Validation Only" mode for testing
// 4. Check validation results table in top-right
// 5. Review console logs for detailed test information
// 6. Switch to trading modes for strategy performance testing
//
// This strategy validates the indicator's outputs and logic without
// requiring separate test data generation.

// ============================================================================
// IMPORT MAIN INDICATOR OUTPUTS
// ============================================================================

// These would be the exposed values from the main indicator
// In practice, you'd need to ensure these match the main indicator's plot names

// Core cycle values (from main indicator's plot statements)
cycleCount = request.security(syminfo.tickerid, timeframe.period, close)  // Placeholder - replace with actual indicator reference
cycleLow = request.security(syminfo.tickerid, timeframe.period, close)    // Placeholder
cycleHigh = request.security(syminfo.tickerid, timeframe.period, close)   // Placeholder

// Cycle state indicators
cycleActive = request.security(syminfo.tickerid, timeframe.period, close)     // Placeholder
inCycleWindow = request.security(syminfo.tickerid, timeframe.period, close)   // Placeholder
cycleComplete = request.security(syminfo.tickerid, timeframe.period, close)   // Placeholder
failedCycle = request.security(syminfo.tickerid, timeframe.period, close)     // Placeholder

// ============================================================================
// STRATEGY CONFIGURATION
// ============================================================================

validationMode = input.bool(false, title="Enable Validation Mode", group="Validation Settings")
strategyType = input.string("Conservative", title="Strategy Type", options=["Conservative", "Aggressive", "Validation Only"], group="Validation Settings")

// Risk management
stopLossPct = input.float(5.0, title="Stop Loss %", minval=1.0, maxval=20.0, group="Risk Management")
takeProfitPct = input.float(10.0, title="Take Profit %", minval=1.0, maxval=50.0, group="Risk Management")
maxDrawdownPct = input.float(15.0, title="Max Drawdown %", minval=5.0, maxval=50.0, group="Risk Management")

// ============================================================================
// VALIDATION LOGIC
// ============================================================================

// Track validation metrics
var int validationTestsRun = 0
var int validationTestsPassed = 0
var int validationTestsFailed = 0

// Validate cycle logic
validateCycleLogic() =>
    if validationMode
        validationTestsRun += 1

        // Test 1: Cycle count should be non-negative when cycle is active
        if cycleActive == 1
            if cycleCount >= 0
                validationTestsPassed += 1
            else
                validationTestsFailed += 1
                log.warning("Validation Failed: Negative cycle count in active cycle")

        // Test 2: When cycle is complete, we should have a cycle high and low
        if cycleComplete == 1
            if not na(cycleLow) and not na(cycleHigh)
                validationTestsPassed += 1
            else
                validationTestsFailed += 1
                log.warning("Validation Failed: Cycle complete but missing high/low values")

        // Test 3: Failed cycle should only trigger when we have previous cycle data
        if failedCycle == 1
            // This would need more complex validation with historical data
            validationTestsPassed += 1  // Simplified for now

        // Test 4: Cycle window logic
        if inCycleWindow == 1
            if cycleActive == 1 and cycleComplete != 1
                validationTestsPassed += 1
            else
                validationTestsFailed += 1
                log.warning("Validation Failed: Inconsistent cycle window state")

// ============================================================================
// TRADING LOGIC BASED ON CYCLE ANALYSIS
// ============================================================================

// Entry signals based on cycle position
longEntrySignal = false
shortEntrySignal = false
exitSignal = false

if strategyType != "Validation Only"
    // Conservative strategy: Buy near cycle lows, sell near cycle highs
    if strategyType == "Conservative"
        // Buy when we're in cycle window and price is near recent low
        if inCycleWindow == 1 and cycleCount > 5 and cycleCount < 20
            if close < cycleLow * 1.05  // Within 5% of cycle low
                longEntrySignal := true

        // Sell when we're approaching cycle high
        if cycleCount > 30 and close > cycleHigh * 0.95  // Within 5% of cycle high
            shortEntrySignal := true

    // Aggressive strategy: More frequent trading
    else if strategyType == "Aggressive"
        // Buy on cycle start
        if cycleActive == 1 and cycleCount < 10
            longEntrySignal := true

        // Sell on cycle completion or failed cycle
        if cycleComplete == 1 or failedCycle == 1
            shortEntrySignal := true

// ============================================================================
// POSITION MANAGEMENT
// ============================================================================

// Track position entry price
var float entryPrice = na

// Calculate dynamic stop loss and take profit levels
stopLossPrice = strategy.position_avg_price * (1 - stopLossPct / 100)
takeProfitPrice = strategy.position_avg_price * (1 + takeProfitPct / 100)

// Exit conditions
if strategy.position_size > 0
    // Stop loss
    if close <= stopLossPrice
        exitSignal := true
        log.info("Exit: Stop Loss triggered at " + str.tostring(close))

    // Take profit
    if close >= takeProfitPrice
        exitSignal := true
        log.info("Exit: Take Profit triggered at " + str.tostring(close))

    // Max drawdown protection
    currentDrawdown = (strategy.position_avg_price - close) / strategy.position_avg_price * 100
    if currentDrawdown >= maxDrawdownPct
        exitSignal := true
        log.info("Exit: Max Drawdown triggered at " + str.tostring(currentDrawdown) + "%")

// ============================================================================
// EXECUTE TRADES
// ============================================================================

// Enter long position
if longEntrySignal and strategy.position_size == 0
    strategy.entry("Long", strategy.long)
    entryPrice := close
    log.info("Enter Long at " + str.tostring(close) + " (Cycle Count: " + str.tostring(cycleCount) + ")")

// Enter short position
if shortEntrySignal and strategy.position_size == 0
    strategy.entry("Short", strategy.short)
    entryPrice := close
    log.info("Enter Short at " + str.tostring(close) + " (Cycle Count: " + str.tostring(cycleCount) + ")")

// Exit position
if exitSignal and strategy.position_size != 0
    strategy.close_all()
    log.info("Exit position at " + str.tostring(close))

// ============================================================================
// VALIDATION & MONITORING
// ============================================================================

// Run validation checks
validateCycleLogic()

// Display validation results
if validationMode and barstate.islast
    var table validationTable = table.new(position.top_right, 1, 4,
                                        bgcolor=color.new(color.white, 90),
                                        border_color=color.gray)

    table.cell(validationTable, 0, 0, "Validation Results", text_color=color.black,
               text_size=size.normal, bgcolor=color.blue)
    table.cell(validationTable, 0, 1, "Tests Run: " + str.tostring(validationTestsRun),
               text_color=color.black)
    table.cell(validationTable, 0, 2, "Passed: " + str.tostring(validationTestsPassed),
               text_color=color.green)
    table.cell(validationTable, 0, 3, "Failed: " + str.tostring(validationTestsFailed),
               text_color=color.red)

// ============================================================================
// PERFORMANCE METRICS
// ============================================================================

// Calculate and display performance metrics
if barstate.islast
    totalTrades = strategy.opentrades + strategy.closedtrades
    winRate = strategy.wintrades / max(strategy.closedtrades, 1) * 100
    profitFactor = strategy.grossprofit / max(strategy.grossloss, 1)

    log.info("=== Strategy Performance ===")
    log.info("Total Trades: " + str.tostring(totalTrades))
    log.info("Win Rate: " + str.tostring(winRate, "#.##") + "%")
    log.info("Profit Factor: " + str.tostring(profitFactor, "#.##"))
    log.info("Net Profit: " + str.tostring(strategy.netprofit))
    log.info("Max Drawdown: " + str.tostring(strategy.max_drawdown, "#.##") + "%")

// ============================================================================
// VISUAL INDICATORS
// ============================================================================

// Plot entry/exit signals
plotshape(longEntrySignal, title="Long Entry", location=location.belowbar,
          color=color.green, style=shape.labelup, text="BUY")
plotshape(shortEntrySignal, title="Short Entry", location=location.abovebar,
          color=color.red, style=shape.labeldown, text="SELL")
plotshape(exitSignal, title="Exit", location=location.abovebar,
          color=color.orange, style=shape.labeldown, text="EXIT")

// Plot cycle-based support/resistance levels
plot(cycleLow, title="Cycle Low", color=color.green, linewidth=2, style=plot.style_stepline)
plot(cycleHigh, title="Cycle High", color=color.red, linewidth=2, style=plot.style_stepline)

// ============================================================================
// ALERTS
// ============================================================================

// Alert conditions
alertcondition(longEntrySignal, title="Long Entry Alert", message="Cycle-based Long Entry Signal")
alertcondition(shortEntrySignal, title="Short Entry Alert", message="Cycle-based Short Entry Signal")
alertcondition(exitSignal, title="Exit Alert", message="Position Exit Signal")
alertcondition(failedCycle == 1, title="Failed Cycle Alert", message="Failed Cycle Detected")

// ============================================================================
// USAGE INSTRUCTIONS
// ============================================================================

// USAGE INSTRUCTIONS:
//
// 1. Load this strategy alongside the Bitcoin Cycles Indicator
// 2. In validation mode, it will test the indicator's logic and outputs
// 3. In trading mode, it will execute trades based on cycle analysis
// 4. Monitor the validation results table for any logic errors
// 5. Use the performance metrics to evaluate strategy effectiveness
//
// IMPORTANT NOTES:
// - This strategy requires the main indicator to be loaded first
// - The placeholder security() calls need to be replaced with actual indicator references
// - Adjust risk management parameters based on your risk tolerance
// - Backtest thoroughly before using with real money